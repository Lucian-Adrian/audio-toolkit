
## Phase 0: Project Setup

**Goal:** Establish project skeleton, dependencies, and verify toolchain works.

**Requirements Addressed:** U-001, U-002, U-004

### Atomic Tasks

- [ ] **0.1** Create `pyproject.toml` with project metadata and entry point
  ```toml
  [project]
  name = "audiotoolkit"
  version = "0.1.0"
  [project.scripts]
  audiotoolkit = "src.main:app"
  ```

- [ ] **0.2** Create `requirements.txt` with core dependencies
  ```
  typer>=0.9.0
  rich>=13.0.0
  pydub>=0.25.1
  pyyaml>=6.0
  pydantic>=2.0
  ```

- [ ] **0.3** Create `requirements-dev.txt` with development dependencies
  ```
  pytest>=7.4.0
  pytest-cov>=4.1.0
  pytest-mock>=3.11.0
  black>=23.7.0
  ruff>=0.0.280
  mypy>=1.5.0
  ```

- [ ] **0.4** Create minimal `src/main.py` with Typer app skeleton
  ```python
  import typer
  app = typer.Typer(name="audiotoolkit", help="ðŸŽµ Audio Toolkit")
  
  @app.command()
  def version():
      """Show version."""
      typer.echo("audiotoolkit v0.1.0")
  
  if __name__ == "__main__":
      app()
  ```

- [ ] **0.5** Create `src/__init__.py`, `src/core/__init__.py`, `src/utils/__init__.py`

- [ ] **0.6** Create `tests/conftest.py` with basic pytest configuration

- [ ] **0.7** Create `data/` directory structure: `logs/`, `output/`, `sessions/`, `presets/`

- [ ] **0.8** Update `.gitignore` to exclude `data/`, `*.pyc`, `__pycache__/`, `.venv/`

- [ ] **0.9** Create virtual environment and install dependencies
  ```bash
  python -m venv .venv
  .venv\Scripts\activate  # Windows
  pip install -r requirements.txt -r requirements-dev.txt
  ```

- [ ] **0.10** Verify installation works
  ```bash
  python -m src.main --help
  ```

### Verification Step
```bash
# Run these commands - all must pass
python -m src.main --help          # Shows help text
python -m src.main version         # Shows "audiotoolkit v0.1.0"
pytest --collect-only              # Collects 0 tests (no errors)
mypy src/ --ignore-missing-imports # No errors
```

**Exit Criteria:** `audiotoolkit --help` displays usage information.

---

## Phase 1: Foundation Layer

**Goal:** Build the infrastructure layer that all processors depend on.

**Requirements Addressed:** U-001 to U-006, U-011, U-012

### Atomic Tasks

#### 1.1 Core Types & Exceptions (`src/core/`)

- [ ] **1.1.1** Create `src/core/types.py` with shared type definitions
  ```python
  from pathlib import Path
  from typing import TypeAlias
  
  AudioPath: TypeAlias = Path
  SupportedFormat = Literal["wav", "mp3", "flac", "ogg", "aac", "m4a"]
  DecibelLevel: TypeAlias = float  # in dB
  DurationMs: TypeAlias = int      # milliseconds
  ```

- [ ] **1.1.2** Create `src/core/exceptions.py` with exception hierarchy
  - `AudioToolkitError` (base)
  - `ConfigError`, `InvalidYAMLError`, `MissingParameterError`
  - `ProcessingError`, `CorruptedFileError`, `UnsupportedFormatError`
  - `SessionError`, `SessionLockedError`, `SessionNotFoundError`
  - `PluginError`, `PluginInterfaceError`

- [ ] **1.1.3** Create `src/core/interfaces.py` with `AudioProcessor` ABC
  - Properties: `name`, `version`, `description`, `category`
  - Methods: `process()`, `get_parameters()`, `validate_config()`
  - Dataclasses: `ParameterSpec`, `ProcessResult`, `ProcessorCategory`

- [ ] **1.1.4** Create `src/core/interfaces.py` with `SessionStore` ABC
  - Dataclasses: `Session`, `FileRecord`, `SessionStatus`, `FileStatus`
  - Methods: `create_session()`, `get_session()`, `update_file_status()`, `checkpoint()`

- [ ] **1.1.5** Write unit tests for dataclasses (`tests/unit/test_types.py`)
  - Test `ProcessResult` creation with all fields
  - Test `ParameterSpec` validation
  - Test enum values for `SessionStatus`, `FileStatus`

#### 1.2 Utilities (`src/utils/`)

- [ ] **1.2.1** Create `src/utils/logger.py` with Rich-based logging
  ```python
  from rich.console import Console
  from rich.logging import RichHandler
  import logging
  
  console = Console()
  
  def setup_logging(verbose: bool = False) -> logging.Logger:
      level = logging.DEBUG if verbose else logging.INFO
      logging.basicConfig(
          level=level,
          format="%(message)s",
          handlers=[RichHandler(console=console, rich_tracebacks=True)]
      )
      return logging.getLogger("audiotoolkit")
  ```

- [ ] **1.2.2** Create `src/utils/file_ops.py` with file utilities
  ```python
  def scan_audio_files(directory: Path, recursive: bool = True) -> list[Path]:
      """Scan directory for supported audio files."""
      
  def ensure_output_dir(path: Path) -> Path:
      """Create output directory if not exists, return path."""
      
  def generate_output_filename(
      input_path: Path, 
      suffix: str, 
      output_dir: Path,
      segment_num: int | None = None
  ) -> Path:
      """Generate output filename following naming convention."""
  ```

- [ ] **1.2.3** Create `src/utils/audio.py` with pydub wrapper
  ```python
  from pydub import AudioSegment
  
  def load_audio(path: Path) -> AudioSegment:
      """Load audio file, raise CorruptedFileError on failure."""
      
  def save_audio(audio: AudioSegment, path: Path, format: str) -> None:
      """Save audio to file."""
      
  def get_audio_info(path: Path) -> dict:
      """Return duration_ms, channels, sample_rate, format."""
  ```

- [ ] **1.2.4** Create `src/utils/config.py` with YAML loader
  ```python
  def load_yaml_config(path: Path) -> dict:
      """Load and validate YAML config, raise InvalidYAMLError on failure."""
      
  def validate_pipeline_config(config: dict) -> list[str]:
      """Return list of validation errors (empty if valid)."""
  ```

- [ ] **1.2.5** Create `src/utils/progress.py` with Rich progress bars
  ```python
  from rich.progress import Progress, TaskID
  
  class ProgressReporter:
      def start(self, total: int, description: str) -> None: ...
      def update(self, advance: int = 1) -> None: ...
      def finish(self) -> None: ...
  ```

- [ ] **1.2.6** Create `src/utils/validators.py` with input validation
  ```python
  def validate_audio_path(path: Path) -> Path:
      """Validate path exists and is supported format."""
      
  def validate_output_dir(path: Path, create: bool = True) -> Path:
      """Validate output directory is writable."""
      
  def validate_duration(seconds: float) -> float:
      """Validate duration is positive."""
  ```

- [ ] **1.2.7** Write unit tests for utilities (`tests/unit/test_utils.py`)
  - Test `scan_audio_files` with mock directory
  - Test `load_audio` with valid/invalid files
  - Test `load_yaml_config` with valid/invalid YAML
  - Test validators with edge cases

### Verification Step
```bash
# All tests must pass
pytest tests/unit/test_types.py -v
pytest tests/unit/test_utils.py -v

# Type checking
mypy src/core/ src/utils/ --strict

# Import test - all modules should import without error
python -c "from src.core.interfaces import AudioProcessor, ProcessResult"
python -c "from src.utils.logger import setup_logging"
python -c "from src.utils.audio import load_audio"
```

**Exit Criteria:** All foundation modules importable, 100% test coverage on utils.

---

## Phase 2: MVP Processors

**Goal:** Implement Fixed Splitter and Format Converter as pure functions.

**Requirements Addressed:** SPLIT-001, SPLIT-004, SPLIT-005, CONV-001 to CONV-004

### Atomic Tasks

#### 2.1 Fixed Duration Splitter

- [ ] **2.1.1** Create `src/processors/__init__.py` with processor registry

- [ ] **2.1.2** Create `src/processors/splitter/__init__.py` with exports

- [ ] **2.1.3** Create `src/processors/splitter/base.py` with shared splitter logic
  ```python
  from src.core.interfaces import AudioProcessor, ProcessResult, ParameterSpec
  
  class BaseSplitter(AudioProcessor):
      """Base class for all splitter implementations."""
      
      @property
      def category(self) -> ProcessorCategory:
          return ProcessorCategory.CORE
      
      def _save_segments(
          self, 
          segments: list[AudioSegment], 
          input_path: Path,
          output_dir: Path,
          format: str
      ) -> list[Path]:
          """Save segments to files, return output paths."""
  ```

- [ ] **2.1.4** Create `src/processors/splitter/fixed.py` implementing `FixedSplitter`
  ```python
  class FixedSplitter(BaseSplitter):
      @property
      def name(self) -> str:
          return "splitter-fixed"
      
      @property
      def version(self) -> str:
          return "1.0.0"
      
      @property
      def description(self) -> str:
          return "Split audio into fixed-duration segments"
      
      def get_parameters(self) -> list[ParameterSpec]:
          return [
              ParameterSpec(
                  name="duration",
                  param_type="float",
                  required=True,
                  description="Segment duration in seconds",
                  min_value=0.1
              ),
              ParameterSpec(
                  name="format",
                  param_type="choice",
                  required=False,
                  default="wav",
                  choices=["wav", "mp3", "flac"]
              )
          ]
      
      def process(
          self, 
          input_path: Path, 
          output_dir: Path, 
          duration: float,
          format: str = "wav",
          **kwargs
      ) -> ProcessResult:
          """Pure function: Read file â†’ Split â†’ Write segments â†’ Return result."""
  ```

- [ ] **2.1.5** Write comprehensive tests (`tests/unit/test_splitter_fixed.py`)
  ```python
  def test_fixed_splitter_correct_segment_count():
      """AC-SPLIT-1: 10-min file with 60s duration = 10 segments."""
      
  def test_fixed_splitter_handles_remainder():
      """AC-SPLIT-2: 10-min file with 180s = 3x180s + 1x60s."""
      
  def test_fixed_splitter_short_file():
      """EC-SPLIT-1: File shorter than duration = 1 segment + warning."""
      
  def test_fixed_splitter_output_naming():
      """AC-SPLIT-5: Output follows {name}_segment_{NNN}.{ext} pattern."""
      
  def test_fixed_splitter_is_pure_function():
      """Verify process() has no side effects beyond file output."""
  ```

- [ ] **2.1.6** Create test fixtures (`tests/fixtures/audio/`)
  - Generate 10-second mono WAV file
  - Generate 60-second stereo MP3 file
  - Generate file with silence gaps

#### 2.2 Format Converter

- [ ] **2.2.1** Create `src/processors/converter.py` implementing `FormatConverter`
  ```python
  class FormatConverter(AudioProcessor):
      @property
      def name(self) -> str:
          return "converter"
      
      def get_parameters(self) -> list[ParameterSpec]:
          return [
              ParameterSpec(name="format", param_type="choice", required=True, 
                           choices=["wav", "mp3", "flac", "ogg", "aac", "m4a"]),
              ParameterSpec(name="normalize", param_type="bool", default=False),
              ParameterSpec(name="target_lufs", param_type="float", default=-14.0),
          ]
      
      def process(
          self, 
          input_path: Path, 
          output_dir: Path,
          format: str,
          normalize: bool = False,
          target_lufs: float = -14.0,
          **kwargs
      ) -> ProcessResult:
          """Pure function: Convert format, optionally normalize."""
  ```

- [ ] **2.2.2** Write tests (`tests/unit/test_converter.py`)
  ```python
  def test_converter_wav_to_mp3():
      """CONV-001: Convert WAV to MP3."""
      
  def test_converter_skip_same_format():
      """CONV-004: Skip if source == target format."""
      
  def test_converter_normalize_audio():
      """CONV-002: Normalize to -14 LUFS."""
      
  def test_converter_is_pure_function():
      """Verify no side effects."""
  ```

#### 2.3 CLI Integration

- [ ] **2.3.1** Create `src/presentation/__init__.py`

- [ ] **2.3.2** Create `src/presentation/cli/__init__.py`

- [ ] **2.3.3** Create `src/presentation/cli/split_cmd.py`
  ```python
  import typer
  from pathlib import Path
  
  app = typer.Typer()
  
  @app.command("fixed")
  def split_fixed(
      input: Path = typer.Option(..., "--input", "-i", help="Input file or directory"),
      output: Path = typer.Option("./data/output", "--output", "-o"),
      duration: float = typer.Option(..., "--duration", "-d", help="Segment duration (seconds)"),
      format: str = typer.Option("wav", "--format", "-f"),
      recursive: bool = typer.Option(True, "--recursive/--no-recursive"),
  ):
      """Split audio into fixed-duration segments."""
  ```

- [ ] **2.3.4** Create `src/presentation/cli/convert_cmd.py`
  ```python
  @app.command()
  def convert(
      input: Path = typer.Option(..., "--input", "-i"),
      output: Path = typer.Option("./data/output", "--output", "-o"),
      format: str = typer.Option(..., "--format", "-f"),
      normalize: bool = typer.Option(False, "--normalize"),
      recursive: bool = typer.Option(True, "--recursive/--no-recursive"),
  ):
      """Convert audio files to different format."""
  ```

- [ ] **2.3.5** Update `src/main.py` to register CLI commands
  ```python
  from src.presentation.cli import split_cmd, convert_cmd
  
  app.add_typer(split_cmd.app, name="split")
  app.add_typer(convert_cmd.app, name="convert")
  ```

- [ ] **2.3.6** Write CLI integration tests (`tests/integration/test_cli.py`)
  ```python
  from typer.testing import CliRunner
  
  def test_split_fixed_cli():
      """Test: audiotoolkit split fixed --input test.wav --duration 10"""
      
  def test_convert_cli():
      """Test: audiotoolkit convert --input test.wav --format mp3"""
  ```

### Verification Step
```bash
# Unit tests for processors
pytest tests/unit/test_splitter_fixed.py -v --cov=src/processors/splitter
pytest tests/unit/test_converter.py -v --cov=src/processors/converter

# Integration tests
pytest tests/integration/test_cli.py -v

# Manual CLI test
audiotoolkit split fixed --input tests/fixtures/audio/10sec_mono.wav --duration 3 --output ./data/output
ls ./data/output  # Should show: 10sec_mono_segment_001.wav, ..._002.wav, ..._003.wav, ..._004.wav

audiotoolkit convert --input tests/fixtures/audio/10sec_mono.wav --format mp3 --output ./data/output
ls ./data/output  # Should show: 10sec_mono.mp3

# Type checking
mypy src/processors/ --strict
```

**Exit Criteria:** 
- `audiotoolkit split fixed` produces correct segments
- `audiotoolkit convert` produces correct output format
- All tests pass with >90% coverage on processors

---
